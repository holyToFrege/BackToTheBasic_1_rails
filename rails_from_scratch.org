#+TITLE: rails from scratch
#+AUTHOR: Hoyoul Park
#+DESCRIPTION: Org-HTML export made simple.
#+KEYWORDS:  org-mode, export, html, theme, style, css, js, bigblow
#+LANGUAGE:  en
#+OPTIONS:   H:4 toc:t num:2
#+MACRO: color @@html:<font color=></font>@@
#+PROPERTY:  header-args :padline no
#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup
#+LATEX_HEADER: \usepackage{kotex}
#+latex_header: \hypersetup{colorlinks=true}

* 맨 처음 해야 하는것(1. Local 개발환경 만들기)
#+begin_note
local에서 작업할수 있는 환경을  만든다. gorails에서 지시하는대로 한다. 그 다음 capistrano를 통해 운영서버에 적용하는 환경을 만들것이다. 두 환경은 하나의 rails project에서 동시에 운영된다. 아무 문제 없다. 즉 capistrano 설정을 하면 local에서 작업하지 못하고, local에서 별도로 rails new railsproject를 사용해서 local용을 만들 필요가 없다는 것이다. 하나의 rails 프로젝트에서 test하고 rails s로 local test하고 제대로 되면 운영서버로 배포하는 형태를 가지면 된다.
#+end_note
** local 개발환경
*** ruby 설치(with rbenv)
#+begin_note
rails는 ruby version을 탄다. rails와 ruby version이 궁합이 맞아야 하고, gem들도 맞아야 한다. ruby설치는 rbenv를 사용한다.
#+end_note
#+begin_note
rbenv는 여러버전의 ruby를 설치할 수 있는데, 이것이 가능한것은 ruby-build라는 plugin이 있기에 가능하다. rbenv install 3.14 이런식으로 ruby를 설치하는것은 rbenv-build에 있는 rbenv-install에 의해서 가능한 것이다. pyenv도 동일한 형식이다.
#+end_note

 #+begin_tip
 brew install rbenv ruby-build

# Add rbenv to bash so that it loads every time you open a terminal
echo 'if which rbenv > /dev/null; then eval "$(rbenv init -)"; fi' >> ~/.zshrc
source ~/.zshrc

# Install Ruby
rbenv install 3.0.1
rbenv global 3.0.1
ruby -v
 #+end_tip
*** git 설치와 설정
#+begin_note
rails는 기본적으로 git init의 과정으로 local git을 설정한다. 그래서 git이 이미 system에 설치되어 있어야 하고, git에 대한 설정을 해야 한다. 그리고 github에 저장해야 하기 때문에, ssh도 만들어야 한다.
#+end_note
 #+begin_tip
git config --global color.ui true
git config --global user.name "holy"
git config --global user.email "holy@fastmail.com"
ssh-keygen만 해도 된다.
 #+end_tip
*** rails 설치
#+begin_note
gem은 ruby를 설치하면 자동으로 같이 설치된다. gem을 이용해서 rails를 설치한다.
gem install rails -v 6.1.3.2 
#+end_note
#+begin_note
한가지 특이한건, gem으로 설치한 rails를 사용하기 위해선 rbenv에게
rails가 설치되었다는 것을 알려줘야 한다는 것이다.
#+end_note
 #+begin_tip
 rbenv rehash를 해야만 rails를 사용할 수 있다.
 #+end_tip
*** Database 설치
#+begin_note
brew install mysql
brew services start mysql
#+end_note
*** nokogiri, pg를 위한 설치
#+begin_note
원래는 다음을 실행해야 하는데, 설치가 제대로 안된다.
----다음----
sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target /

아래를 설치한다.
brew install libxml2 libxslt
gem install nokogiri --platform=ruby -- --use-system-libraries
#+end_note
*** rails server
#+begin_note
rails new mysite --database=mysql
rails db:setup
rails db:migrate
rails s
#+end_note
* Production Server 설치
*  새로운 webapp만들기(Local server와 production을 위한 capistrano가 설치된 상황에서)
** github에 project를 만든다.
** rails new webapp 
** git push로 github에 반영
** capistrano gem설치
#+begin_note
 project를 새로 만들었기 때문에 capistrano gem이 설치가 안되어 있을 것이다. capistrano를 설치해야만 deploy.rb와 deploy폴더가 만들어지고, 거기에서 github과 server에 대한 설정을 할 수 있다.
 #+end_note
아래의 gem을 Gemfile에 설정한다.
#+begin_note
gem 'capistrano', '~> 3.11'
gem 'capistrano-rails', '~> 1.4'
gem 'capistrano-passenger', '~> 0.2.0'
gem 'capistrano-rbenv', '~> 2.1', '>= 2.1.4'
#+end_note
- bundle
  bundle은 Gemfile의 gem을 /Users/holy/.rbenv/versions/3.0.1/lib/ruby/gems/3.0.0/gems에 설치한다.
- cap install 
   cap install을 하면 depoly.rb와 deploy폴더가 생성되고, STAGE를 production이라고 했기 때문에 deploy/production.rb가 만들어진다. STAGES라는 것은  server를 나타낸다. 운영서버는 3개가 될 수도 있고, 4개도 될 수 있다. 각각의 이름이 있고, 각각의 deploy설정이 가능하다. cap install로 만들어지는 것은 다음과 같다.
   
   1) config/deploy.rb
   2) config/deploy/production.rb
   3) lib/capistrano/tasks
   4) Capfiles
#+begin_note
   bundle
   cap install STAGES=production
#+end_note
** capistrano가 github과 aws와 db 접속할 수 있는 환경 설정
*** github check
#+begin_note
keychain을 실행해서 github.com을 찾는다. id와 pw가 github의 id와 pw와 같은지 확인한다. 동일하지 않다면 동일하게 해준다.
#+end_note
*** github settings (capistrano는 config/deploy.rb를 참고한다.)
#+begin_note
capistrano는 github에 접속해서 branch에 있는 source를 운영서버에 배포한다.
아래정보로 추정하면 다음과 같다.
github에 있는 myapp의 main branch source를  /home/deploy/myapp에 배포하라.  /home/deploy라고 한 이유는 deploy사용자의 home이기 때문이다. 즉 aws에 접속하는 계정은 deploy임을 알수 있다. aws에 접속해야 한다는 것도 알 수 있다. aws 설정정보는 production.rb에 있다.
#+end_note
#+begin_note
set :application, "myapp"  => project app이름
set :repo_url, "git@github.com:PnC-jeju/myapp.git"  => github위치
set :branch, "main" => 배포할려는 branch
set :deploy_to, "/home/deploy/#{fetch :application}" => 배포 위치
append :linked_dirs, 'log', 'tmp/pids', 'tmp/cache', 'tmp/sockets', 'vendor/bundle', '.bundle', 'public/system', 'public/uploads'
set :keep_releases, 5
#+end_note
*** aws와 db환경 설정(config/deploy/production.rb)
#+begin_note
production.rb의 설정은 단순하다. 아래처럼 server의 위치와 loginid만 기술한다.
#+end_note
#+begin_note
server "13.125.158.130", user: "deploy", roles: %w{app db web}
#+end_note
*** git과 aws의 password?
#+begin_note
git과 aws에 접속하기 위해서 password가 필요하다. 이것을 하기 위해선 다음과 같은 작업이 필요하다.
#+end_note
 #+begin_tip
 ssh-add ~/.ssh/company-ec2-keys.pem
 ssh-add ~/.ssh/id_rsa
 #+end_tip
*** cd config, cap production deploy
#+begin_note
이렇게 하고 cap production deploy하는 경우, 위에서 정의한 설정(production.rb,deploy.rb)을 읽고 capfile을 실행한다. capfile은 task들을 정의한 library가 있는데, 그 library를 실행한다.
#+end_note
*** capfile
#+begin_note
cap은 capfile에 기술된 task를 실행한다.
#+end_note
#+begin_note
require "capistrano/setup"
require "capistrano/deploy"
require "capistrano/scm/git"
install_plugin Capistrano::SCM::Git

Dir.glob("lib/capistrano/tasks/*.rake").each { |r| import r }
#+end_note
#+begin_note
위에 기술된게 default task이다. 이것은 git과 deploy관련된 task만을 한다. 즉 git에 접속해서 git의 branch에 있는 source code를 가져와서 aws ec2에 접속한후 source가 위치할 release폴더를 만들고 복사하는 일까지 한다. 아래 그림은 default task이 setup,deploy,git만을 실행했을 때 처리과정이다.
#+end_note
#+CAPTION: capistrano1
#+NAME: 
#+attr_html: :width 800px
#+attr_latex: :width 100px
[[./img/capi1.png]]
#+CAPTION: capistrano2
#+NAME: 
#+attr_html: :width 800px
#+attr_latex: :width 100px
[[./img/capi2.png]]
*** nginx서버와 passenger를 키고 새로만든 rails app을 연동시키려면?
#+begin_note
2가지가 필요하다. 첫번째 nginx->passenger->rails app을 호출하는 구조이기 때문에 nginx의 sites_enabled폴더에 보면  rails app이름이 있다. 새로만든 rails app이름으로 해주어야 한다. 두번째 capistrano는 capfile에서 git과 deploy만 했다. 실제 nginx, passenger,rails app에 대한 task는 하지 않고 있다. 이것을 해줘야 한다.
#+end_note
**** (1) nginx에서 수행할 rails app지정
#+CAPTION: nginx1
#+NAME: 
#+attr_html: :width 800px
#+attr_latex: :width 100px
[[./img/nginx1.png]]
#+begin_note
nginx가 시작되면 nginx는 사용할 rails app을 sites_enabled에 기술했다. 여기에 보면, myapp이란 파일이 보이는데, myapp의 이름을 새로운 rails app이름으로 바꾸고, 안에 있는 내용도 새로운 rails-app에 맞추어 바꾼다. 
#+end_note
**** (2) Capfile에 web server관련 task 추가
#+begin_note
require 'capistrano/rails'
require 'capistrano/passenger'
require 'capistrano/rbenv'

set :rbenv_type, :user
set :rbenv_ruby, '3.0.1'
#+end_note
*** [Final] DB 처리
#+begin_note
capistrano가 하는 일 중 DB접속이 있다. 언제 db접속을 할까? capistrano는 github의 source code를 aws ec2의 release 폴더에 넣고, bundler를 수행해서 gem을 설치하고, server를 실행하기전에 db:migrate같은 db작업을 하는데, db의 위치, 종류 등의 설정이 필요하다. 첫번째로 생각할 수 있는게, mysql2라는 gem이 gemfiles에 있는지 확인해야 한다. 두번째로 database.yml이라는 설정파일이다. sqlite3로 되어 있을 것이다. 우리는 mariadb를 사용하기 때문에 그것에 맞추어 기술해야 한다. 세번째로 rbenv-vars라는 파일을 기술하는 것이다.
#+end_note
**** [1] gem mysql2를 Gemfile에 추가.
#+CAPTION: mysql2
#+NAME: 
#+attr_html: :width 800px
#+attr_latex: :width 100px
[[./img/mysql2.png]]

#+begin_note
위와 같이 version을 잘 맞추어 넣어준 후에,  bundle, bundle update를 한다. 그 이후 git에 반영을 해야 한다.
#+end_note
**** [2] database.yml처리
#+begin_note
database.yml에는 접속정보와 database관련 정보가 있기 때문에 잘 설정해야한다. local에서 db접속하는 경우와 production에서 db에 접속하는 두 가지 경우를 잘 살펴봐야 한다.  production에서 kwaterdb라는 database와 user의 이름은 webuser01이란 userid로 설정했다. 이 설정값은 .rbenv-vars라는 파일에도 비슷하게 기술할 수 있기 때문이다. 그리고 socket파일도  os마다 다른 경로를 갖을 수 있다.
#+end_note
#+CAPTION: rbenvars2
#+NAME: 
#+attr_html: :width 800px
#+attr_latex: :width 100px
[[./img/rbenvaras2.png]]

**** [3] .rbenv-vars변수 처리
#+CAPTION: mysql3
#+NAME: 
#+attr_html: :width 800px
#+attr_latex: :width 100px
[[./img/rbenvars.png]]
#+begin_note

#+end_note
*** error처리
**** bundle에서 에러
#+begin_note
Your bundle only supports platforms ["x86_64-darwin-19"] but your local platform is x86_64-linux. Add the current platform to the lockfile with 'bundle lock --add-platform x86_64-linux' and try again.
#+end_note
#+begin_note
bundle lock --add-platform x86_64-linux
# commit & push
#+end_note
**** DB관련 권한 문제
#+begin_note
우선 사용자가 사용할 수 있는 db여야 한다. 즉 mysql -udeploy로 접속해서 show databases;를 해서 db가 있는지 확인해야 한다. 그런 다음에 해당 db의 모든 권한을 줘야 한다. 예를 들어서 deploy란 사용자가 kwaterdb라는 db가 있다면,  다음 코드를 추가한다.
#+end_note
#+begin_note
GRANT ALL PRIVILEGES ON kwaterdb.* TO 'deploy'@'localhost';
GRANT ALL PRIVILEGES ON kwaterdb.* TO 'deploy'@'%';
FLUSH PRIVILEGES;
#+end_note
